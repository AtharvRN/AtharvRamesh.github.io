<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Edge ML Pipelines That Don’t Drop Frames — Atharv Nair</title>
    <meta
      name="description"
      content="Engineering notes on keeping multi-model ADAS stacks under latency budgets on embedded hardware."
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../style.css" />
    <link rel="icon" type="image/png" href="../assets/profile.png" />
  </head>
  <body>
    <header class="site-header">
      <nav class="nav">
        <a class="brand" href="../">Atharv Nair</a>
        <button class="nav-toggle" aria-label="Toggle navigation">
          <span></span>
          <span></span>
          <span></span>
        </button>
        <ul class="nav-links">
          <li><a href="../#about">About</a></li>
          <li><a href="../#experience">Experience</a></li>
          <li><a href="../#projects">Projects</a></li>
          <li><a href="../#publications">Publications</a></li>
          <li><a href="./">Blog</a></li>
          <li><a href="../#contact">Contact</a></li>
        </ul>
      </nav>
      <section class="section">
        <div class="section-heading">
          <h1>Edge ML Pipelines That Don’t Drop Frames</h1>
          <p class="footnote">July 2024 · 4 minute read</p>
        </div>
      </section>
    </header>

    <main class="section">
      <article class="publication-card">
        <p>
          At Netradyne we support multiple perception models per camera stream,
          running on a mix of Qualcomm SNPE and NVIDIA TensorRT targets. The old
          pipeline would occasionally drop frames whenever workloads spiked. The
          fix was a re-architecture that made scheduling explicit.
        </p>
        <h3>Producer–consumer scheduling</h3>
        <p>
          We replaced the monolithic loop with a producer that timestamps frames
          and consumers that own model batches. Each consumer has a bounded
          queue. Priority boosts route safety-critical models to the front when
          the queue grows.
        </p>
        <h3>Async I/O &amp; profiling</h3>
        <p>
          Camera reads and writes now run asynchronously, so GPU kernels stay
          fed even when storage hiccups. Extensive tracing hooks feed a Grafana
          dashboard, making regressions obvious during on-road tests.
        </p>
        <h3>Results</h3>
        <p>
          Zero frame drops under stress testing, a 17% throughput increase, and
          room to slot in new perception models without re-tuning budgets. You
          can adapt the scheduler or priority queue implementation from the
          reference snippets I shared internally—ping me if you'd like a clean
          version for your stack.
        </p>
      </article>
    </main>

    <footer class="site-footer">
      <div class="footer-content">
        <h2>Continue exploring</h2>
        <ul class="contact-links">
          <li><a href="./">Back to Notes</a></li>
          <li><a href="../#projects">Selected Projects</a></li>
        </ul>
        <p class="footnote">
          &copy; <span id="year"></span> Atharv Nair.
        </p>
      </div>
    </footer>

    <script>
      const nav = document.querySelector(".nav");
      const toggle = document.querySelector(".nav-toggle");
      const links = document.querySelector(".nav-links");

      toggle?.addEventListener("click", () => {
        links.classList.toggle("is-open");
        nav.classList.toggle("is-open");
      });

      document.querySelectorAll(".nav-links a").forEach((anchor) => {
        anchor.addEventListener("click", () => {
          links.classList.remove("is-open");
          nav.classList.remove("is-open");
        });
      });

      document.getElementById("year").textContent = new Date().getFullYear();
    </script>
  </body>
</html>
